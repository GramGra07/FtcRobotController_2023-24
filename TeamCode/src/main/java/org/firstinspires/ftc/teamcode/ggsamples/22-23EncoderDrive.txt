//encoder

    //public void encoderComboFwd(double speed, double lInches, double rInches,
    //                            double pose, double timeoutS, boolean isUp) {
    //    int newLeftTarget;
    //    int newRightTarget;
    //    int newDLeftTarget;
    //    int newDRightTarget;
    //    int target;
    //    target = (int) pose;
    //    zArmMotor.setTargetPosition(target);
    //    zArmMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //
    //    newLeftTarget = motorBackLeft.getCurrentPosition() + (int) (lInches * COUNTS_PER_INCH);
    //    newRightTarget = motorBackRight.getCurrentPosition() + (int) (rInches * COUNTS_PER_INCH);
    //    //newDLeftTarget = deadWheelL.getCurrentPosition() + (int) (lInches * COUNTS_PER_INCH_dead);
    //    //newDRightTarget = deadWheelR.getCurrentPosition() + (int) (rInches * COUNTS_PER_INCH_dead);
    //
    //    //deadWheelL.setTargetPosition(-newDLeftTarget);
    //    //deadWheelR.setTargetPosition(-newDRightTarget);
    //    motorFrontRight.setTargetPosition(-newRightTarget);
    //    motorBackRight.setTargetPosition(-newRightTarget);
    //    motorFrontLeft.setTargetPosition(-newLeftTarget);
    //    motorBackLeft.setTargetPosition(-newLeftTarget);
    //
    //    motorBackRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //    motorBackLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //    motorFrontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //    motorFrontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //    //deadWheelL.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //    //deadWheelR.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //
    //    runtime.reset();
    //    if (isUp) {
    //        sparkLong.setPower(speed);//go down
    //    }
    //    if (!isUp) {
    //        sparkLong.setPower(-speed);
    //    }
    //    motorBackLeft.setPower((speed));
    //    motorBackRight.setPower((speed));
    //    motorFrontRight.setPower((speed));
    //    motorFrontLeft.setPower((speed));
    //    while (myOpMode.opModeIsActive() &&
    //            (runtime.seconds() < timeoutS) && sparkLong.isBusy()) {
    //
    //        // Display it for the driver.
    //        telemetry.addData(" arm Running to", sparkLong.getCurrentPosition());
    //        telemetry.addData("arm Currently at",
    //                sparkLong.getCurrentPosition());
    //        // Display it for the driver.
    //        telemetry.update();
    //    }
    //
    //    // Stop all motion;
    //    motorBackLeft.setPower(0);
    //    motorFrontRight.setPower(0);
    //    motorBackRight.setPower(0);
    //    motorFrontLeft.setPower(0);
    //
    //    sparkLong.setPower(0);
    //    sparkLong.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    // Turn off RUN_TO_POSITION
    //    motorBackLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    motorBackRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    motorFrontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    motorFrontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    //deadWheelR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    //deadWheelL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    resetEncoders();
    //    telemetry.update();
    //}

//    public static void encoderDrive(double speed,
//                                    double leftInches, double rightInches,
//                                    double timeoutS) {
//        int newLeftTarget;
//        int newRightTarget;
//        int newDLeftTarget;
//        int newDRightTarget;
//        if (myOpMode.opModeIsActive()) {
//
//            newLeftTarget = motorBackLeft.getCurrentPosition() + (int) (leftInches * COUNTS_PER_INCH);
//            newRightTarget = motorBackRight.getCurrentPosition() + (int) (rightInches * COUNTS_PER_INCH);
//            //newDLeftTarget = deadWheelL.getCurrentPosition() + (int) (leftInches * COUNTS_PER_INCH_dead);
//            //newDRightTarget = deadWheelR.getCurrentPosition() + (int) (rightInches * COUNTS_PER_INCH_dead);
//
//            //deadWheelL.setTargetPosition(-newDLeftTarget);
//            //deadWheelR.setTargetPosition(-newDRightTarget);
//            motorFrontRight.setTargetPosition(-newRightTarget);
//            motorBackRight.setTargetPosition(-newRightTarget);
//            motorFrontLeft.setTargetPosition(-newLeftTarget);
//            motorBackLeft.setTargetPosition(-newLeftTarget);
//
//            motorBackRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            motorBackLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            motorFrontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            motorFrontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            //deadWheelL.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            //deadWheelR.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//
//            timer.reset();
//            motorBackLeft.setPower((speed));
//            motorFrontRight.setPower((speed));
//            motorFrontLeft.setPower((speed));
//            motorBackRight.setPower((speed));
//            while (myOpMode.opModeIsActive() &&
//                    (timer.seconds() < timeoutS) &&
//                    (motorBackLeft.isBusy())) {
//
//                // Display it for the driver.
//                //telemetry.addData("Running to", "%7d :%7d", -newDLeftTarget, -newDRightTarget);//"%7d :%7d"
//                //telemetry.addData("Currently at", "%7d :%7d",
//                //        deadWheelL.getCurrentPosition(), deadWheelR.getCurrentPosition());
//            }
//
//            // Stop all motion;
//            motorBackLeft.setPower(0);
//            motorFrontRight.setPower(0);
//            motorBackRight.setPower(0);
//            motorFrontLeft.setPower(0);
//
//            // Turn off RUN_TO_POSITION
//            motorBackLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            motorBackRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            motorFrontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            motorFrontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            resetEncoders();
//        }
//    }
//
//    public static void sideWaysEncoderDrive(double speed,
//                                            double inches,
//                                            double timeoutS) {//+=right //-=left
//        int newFRTarget;
//        int newFLTarget;
//        int newBRTarget;
//        int newBLTarget;
//        int newDeadTarget;
//        inches *= -1;
//        if (myOpMode.opModeIsActive()) {
//            if (inches < 0) {
//                newFLTarget = motorFrontLeft.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                newBLTarget = motorBackLeft.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                newFRTarget = motorFrontRight.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                newBRTarget = motorBackRight.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                //newDeadTarget = deadWheel.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side_dead);
//                motorFrontLeft.setTargetPosition(-newFLTarget);
//                motorBackLeft.setTargetPosition(newBLTarget);
//                motorBackRight.setTargetPosition(-newBRTarget);
//                motorFrontRight.setTargetPosition(newFRTarget);
//                //deadWheel.setTargetPosition(-newDeadTarget);
//            } else if (inches > 0) {
//                newFLTarget = motorFrontLeft.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                newBLTarget = motorBackLeft.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                newFRTarget = motorFrontRight.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                newBRTarget = motorBackRight.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                //newDeadTarget = deadWheel.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side_dead);
//                motorFrontLeft.setTargetPosition(-newFLTarget);
//                motorBackLeft.setTargetPosition(newBLTarget);
//                motorBackRight.setTargetPosition(-newBRTarget);
//                motorFrontRight.setTargetPosition(newFRTarget);
//                //deadWheel.setTargetPosition(newDeadTarget);
//            } else {
//                motorFrontLeft.setTargetPosition(0);
//                motorBackLeft.setTargetPosition(0);
//                motorBackRight.setTargetPosition(0);
//                motorFrontRight.setTargetPosition(0);
//                //deadWheel.setTargetPosition(0);
//            }
//
//            motorFrontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            motorBackLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            motorBackRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            motorFrontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            //deadWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//
//            timer.reset();
//            motorBackLeft.setPower(Math.abs(speed));
//            motorFrontRight.setPower(Math.abs(speed));
//            motorFrontLeft.setPower(Math.abs(speed));
//            motorBackRight.setPower(Math.abs(speed));
//            while (myOpMode.opModeIsActive() &&
//                    (timer.seconds() < timeoutS) && motorFrontLeft.isBusy()) {
//            }
//
//            // Stop all motion;
//            motorBackLeft.setPower(0);
//            motorFrontRight.setPower(0);
//            motorFrontLeft.setPower(0);
//            motorBackRight.setPower(0);
//
//            // Turn off RUN_TO_POSITION
//            motorFrontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            motorBackLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            motorBackRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            motorFrontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            //deadWheel.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            resetEncoders();
//        }
//    }
//
//    public static void resetEncoders() {
//        motorFrontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
//        motorBackRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
//        motorBackLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
//        motorFrontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
//    }
//
//    //walmart odo
//    public void turn(int degrees) {
//        resetEncoders();
//        if (degrees > 180) {
//            degrees = (360 - degrees) * -1;
//        }
//        if (degrees <= 0) {
//            degrees += 1;
//        }
//        int mult = 360 / (degrees + 1);
//        int inches = (turn / mult);
//        encoderDrive(0.65, -inches, inches, 3);
//        resetEncoders();
//    }
//
//    public void advGoSpot(double currX, double currY, double targetX, double targetY, double power, boolean combo, int pose
//            , boolean isUp, String orientation, double orientationVal, boolean endTurn, int turn) {
//        if (ovrTurn % 180 == 0) {
//            double mult = ovrTurn / 180;
//            orientationVal *= (Math.pow(-1, mult));
//        }
//        if (Objects.equals(orientation, "|")) {
//            double sidewaysInches = (targetX - currX) * xMult;
//            double fwdInches = (targetY - currY) * yMult;
//            fwdInches *= orientationVal;
//            sidewaysInches *= orientationVal;
//            if (currX < targetX) {
//                sideWaysEncoderDrive(power, sidewaysInches, 1);
//            } else if (currX > targetX) {
//                sideWaysEncoderDrive(power, -sidewaysInches, 1);
//            }
//            if (currY < targetY) {
//                if (!combo) {
//                    encoderDrive(power, fwdInches, fwdInches, 6);
//                } else {
//                    encoderDrive(power, fwdInches, fwdInches, 6);
//                    //arm encoder
//                }
//            } else if (currY > targetY) {
//                if (!combo) {
//                    encoderDrive(power, -fwdInches, -fwdInches, 6);
//                } else {
//                    encoderDrive(power, -fwdInches, -fwdInches, 6);
//                    //arm encoder
//                }
//            }
//        }
//        if (endTurn) {
//            turn(turn);
//        }
//        ovrTurn += turn;
//        //telemetry.addData("orientation", orientation);
//        //sleep(5000);
//    }

    //
//vu
    //public void runVu(int timeoutS, boolean giveSpot) {
    //    timer.reset();
    //    while (myOpMode.opModeIsActive()) {// and nothing given back
    //        if (timer.seconds() > timeoutS) {// is over time
    //            //auto select
    //        }
    //        if (tfod != null) {
    //            // getUpdatedRecognitions() will return null if no new information is available since
    //            // the last time that call was made.
    //            List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();
    //            if (updatedRecognitions != null) {
    //                telemetry.addData("# Objects Detected", updatedRecognitions.size());
//
    //                // step through the list of recognitions and display image position/size information for each one
    //                // Note: "Image number" refers to the randomized image orientation/number
    //                for (Recognition recognition : updatedRecognitions) {
    //                    double col = (recognition.getLeft() + recognition.getRight()) / 2;
    //                    double row = (recognition.getTop() + recognition.getBottom()) / 2;
    //                    double width = Math.abs(recognition.getRight() - recognition.getLeft());
    //                    double height = Math.abs(recognition.getTop() - recognition.getBottom());
//
    //                    telemetry.addData("", " ");
    //                    telemetry.addData("Image", "%s (%.0f %% Conf.)", recognition.getLabel(), recognition.getConfidence() * 100);
    //                    telemetry.addData("- Position (Row/Col)", "%.0f / %.0f", row, col);
    //                    telemetry.addData("- Size (Width/Height)", "%.0f / %.0f", width, height);
    //                }
    //                telemetry.update();
    //            }
    //        }
    //    }
    //}

    // color
    //public boolean colorInRange(float red, double targetR, float green, double targetG, float blue, double targetB, float range) {
    //    boolean rCheck = false;
    //    boolean gCheck = false;
    //    boolean bCheck = false;
    //    if (targetR - range < red && red < targetR + range) {
    //        rCheck = true;
    //    }
    //    if (targetG - range < green && green < targetG + range) {
    //        gCheck = true;
    //    }
    //    if (targetB - range < blue && blue < targetB + range) {
    //        bCheck = true;
    //    }
    //    return rCheck && gCheck && bCheck;
    //}
    //
    //public void getAllColorR() {
    //    //gives color values
    //    NormalizedRGBA colorsR = colorSensorR.getNormalizedColors();
    //    Color.colorToHSV(colorsR.toColor(), hsvValues);
    //    telemetry.addLine()
    //            .addData("Red", "%.3f", colorsR.red)
    //            .addData("Green", "%.3f", colorsR.green)
    //            .addData("Blue", "%.3f", colorsR.blue)
    //            .addData("Hue", "%.3f", hsvValues[0])
    //            .addData("Saturation", "%.3f", hsvValues[1])
    //            .addData("Value", "%.3f", hsvValues[2])
    //            .addData("Alpha", "%.3f", colorsR.alpha);
    //    telemetry.addLine()
    //            .addData("Color", colorName)
    //            .addData("RGB", "(" + redValR + "," + greenValR + "," + blueValR + ")");//shows rgb value
    //}
    //
    //public void getAllColorL() {
    //    //gives color values
    //    NormalizedRGBA colors = colorSensorL.getNormalizedColors();
    //    Color.colorToHSV(colors.toColor(), hsvValues);
    //    telemetry.addLine()
    //            .addData("Red", "%.3f", colors.red)
    //            .addData("Green", "%.3f", colors.green)
    //            .addData("Blue", "%.3f", colors.blue)
    //            .addData("Hue", "%.3f", hsvValues[0])
    //            .addData("Saturation", "%.3f", hsvValues[1])
    //            .addData("Value", "%.3f", hsvValues[2])
    //            .addData("Alpha", "%.3f", colors.alpha);
    //    telemetry.addLine()
    //            .addData("Color", colorName)
    //            .addData("RGB", "(" + redValL + "," + greenValL + "," + blueValL + ")");//shows rgb value
    //}