//encoder

    //public void encoderComboFwd(double speed, double lInches, double rInches,
    //                            double pose, double timeoutS, boolean isUp) {
    //    int newLeftTarget;
    //    int newRightTarget;
    //    int newDLeftTarget;
    //    int newDRightTarget;
    //    int target;
    //    target = (int) pose;
    //    zArmMotor.setTargetPosition(target);
    //    zArmMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //
    //    newLeftTarget = motorBackLeft.getCurrentPosition() + (int) (lInches * COUNTS_PER_INCH);
    //    newRightTarget = motorBackRight.getCurrentPosition() + (int) (rInches * COUNTS_PER_INCH);
    //    //newDLeftTarget = deadWheelL.getCurrentPosition() + (int) (lInches * COUNTS_PER_INCH_dead);
    //    //newDRightTarget = deadWheelR.getCurrentPosition() + (int) (rInches * COUNTS_PER_INCH_dead);
    //
    //    //deadWheelL.setTargetPosition(-newDLeftTarget);
    //    //deadWheelR.setTargetPosition(-newDRightTarget);
    //    motorFrontRight.setTargetPosition(-newRightTarget);
    //    motorBackRight.setTargetPosition(-newRightTarget);
    //    motorFrontLeft.setTargetPosition(-newLeftTarget);
    //    motorBackLeft.setTargetPosition(-newLeftTarget);
    //
    //    motorBackRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //    motorBackLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //    motorFrontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //    motorFrontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //    //deadWheelL.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //    //deadWheelR.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    //
    //    runtime.reset();
    //    if (isUp) {
    //        sparkLong.setPower(speed);//go down
    //    }
    //    if (!isUp) {
    //        sparkLong.setPower(-speed);
    //    }
    //    motorBackLeft.setPower((speed));
    //    motorBackRight.setPower((speed));
    //    motorFrontRight.setPower((speed));
    //    motorFrontLeft.setPower((speed));
    //    while (myOpMode.opModeIsActive() &&
    //            (runtime.seconds() < timeoutS) && sparkLong.isBusy()) {
    //
    //        // Display it for the driver.
    //        telemetry.addData(" arm Running to", sparkLong.getCurrentPosition());
    //        telemetry.addData("arm Currently at",
    //                sparkLong.getCurrentPosition());
    //        // Display it for the driver.
    //        telemetry.update();
    //    }
    //
    //    // Stop all motion;
    //    motorBackLeft.setPower(0);
    //    motorFrontRight.setPower(0);
    //    motorBackRight.setPower(0);
    //    motorFrontLeft.setPower(0);
    //
    //    sparkLong.setPower(0);
    //    sparkLong.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    // Turn off RUN_TO_POSITION
    //    motorBackLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    motorBackRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    motorFrontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    motorFrontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    //deadWheelR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    //deadWheelL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    //    resetEncoders();
    //    telemetry.update();
    //}

//    public static void encoderDrive(double speed,
//                                    double leftInches, double rightInches,
//                                    double timeoutS) {
//        int newLeftTarget;
//        int newRightTarget;
//        int newDLeftTarget;
//        int newDRightTarget;
//        if (myOpMode.opModeIsActive()) {
//
//            newLeftTarget = motorBackLeft.getCurrentPosition() + (int) (leftInches * COUNTS_PER_INCH);
//            newRightTarget = motorBackRight.getCurrentPosition() + (int) (rightInches * COUNTS_PER_INCH);
//            //newDLeftTarget = deadWheelL.getCurrentPosition() + (int) (leftInches * COUNTS_PER_INCH_dead);
//            //newDRightTarget = deadWheelR.getCurrentPosition() + (int) (rightInches * COUNTS_PER_INCH_dead);
//
//            //deadWheelL.setTargetPosition(-newDLeftTarget);
//            //deadWheelR.setTargetPosition(-newDRightTarget);
//            motorFrontRight.setTargetPosition(-newRightTarget);
//            motorBackRight.setTargetPosition(-newRightTarget);
//            motorFrontLeft.setTargetPosition(-newLeftTarget);
//            motorBackLeft.setTargetPosition(-newLeftTarget);
//
//            motorBackRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            motorBackLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            motorFrontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            motorFrontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            //deadWheelL.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            //deadWheelR.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//
//            timer.reset();
//            motorBackLeft.setPower((speed));
//            motorFrontRight.setPower((speed));
//            motorFrontLeft.setPower((speed));
//            motorBackRight.setPower((speed));
//            while (myOpMode.opModeIsActive() &&
//                    (timer.seconds() < timeoutS) &&
//                    (motorBackLeft.isBusy())) {
//
//                // Display it for the driver.
//                //telemetry.addData("Running to", "%7d :%7d", -newDLeftTarget, -newDRightTarget);//"%7d :%7d"
//                //telemetry.addData("Currently at", "%7d :%7d",
//                //        deadWheelL.getCurrentPosition(), deadWheelR.getCurrentPosition());
//            }
//
//            // Stop all motion;
//            motorBackLeft.setPower(0);
//            motorFrontRight.setPower(0);
//            motorBackRight.setPower(0);
//            motorFrontLeft.setPower(0);
//
//            // Turn off RUN_TO_POSITION
//            motorBackLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            motorBackRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            motorFrontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            motorFrontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            resetEncoders();
//        }
//    }
//
//    public static void sideWaysEncoderDrive(double speed,
//                                            double inches,
//                                            double timeoutS) {//+=right //-=left
//        int newFRTarget;
//        int newFLTarget;
//        int newBRTarget;
//        int newBLTarget;
//        int newDeadTarget;
//        inches *= -1;
//        if (myOpMode.opModeIsActive()) {
//            if (inches < 0) {
//                newFLTarget = motorFrontLeft.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                newBLTarget = motorBackLeft.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                newFRTarget = motorFrontRight.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                newBRTarget = motorBackRight.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                //newDeadTarget = deadWheel.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side_dead);
//                motorFrontLeft.setTargetPosition(-newFLTarget);
//                motorBackLeft.setTargetPosition(newBLTarget);
//                motorBackRight.setTargetPosition(-newBRTarget);
//                motorFrontRight.setTargetPosition(newFRTarget);
//                //deadWheel.setTargetPosition(-newDeadTarget);
//            } else if (inches > 0) {
//                newFLTarget = motorFrontLeft.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                newBLTarget = motorBackLeft.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                newFRTarget = motorFrontRight.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                newBRTarget = motorBackRight.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side);
//                //newDeadTarget = deadWheel.getCurrentPosition() + (int) (inches * COUNTS_PER_INCH_Side_dead);
//                motorFrontLeft.setTargetPosition(-newFLTarget);
//                motorBackLeft.setTargetPosition(newBLTarget);
//                motorBackRight.setTargetPosition(-newBRTarget);
//                motorFrontRight.setTargetPosition(newFRTarget);
//                //deadWheel.setTargetPosition(newDeadTarget);
//            } else {
//                motorFrontLeft.setTargetPosition(0);
//                motorBackLeft.setTargetPosition(0);
//                motorBackRight.setTargetPosition(0);
//                motorFrontRight.setTargetPosition(0);
//                //deadWheel.setTargetPosition(0);
//            }
//
//            motorFrontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            motorBackLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            motorBackRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            motorFrontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//            //deadWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
//
//            timer.reset();
//            motorBackLeft.setPower(Math.abs(speed));
//            motorFrontRight.setPower(Math.abs(speed));
//            motorFrontLeft.setPower(Math.abs(speed));
//            motorBackRight.setPower(Math.abs(speed));
//            while (myOpMode.opModeIsActive() &&
//                    (timer.seconds() < timeoutS) && motorFrontLeft.isBusy()) {
//            }
//
//            // Stop all motion;
//            motorBackLeft.setPower(0);
//            motorFrontRight.setPower(0);
//            motorFrontLeft.setPower(0);
//            motorBackRight.setPower(0);
//
//            // Turn off RUN_TO_POSITION
//            motorFrontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            motorBackLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            motorBackRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            motorFrontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            //deadWheel.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
//            resetEncoders();
//        }
//    }
//
//    public static void resetEncoders() {
//        motorFrontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
//        motorBackRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
//        motorBackLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
//        motorFrontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
//    }
//
//    //walmart odo
//    public void turn(int degrees) {
//        resetEncoders();
//        if (degrees > 180) {
//            degrees = (360 - degrees) * -1;
//        }
//        if (degrees <= 0) {
//            degrees += 1;
//        }
//        int mult = 360 / (degrees + 1);
//        int inches = (turn / mult);
//        encoderDrive(0.65, -inches, inches, 3);
//        resetEncoders();
//    }
//
//    public void advGoSpot(double currX, double currY, double targetX, double targetY, double power, boolean combo, int pose
//            , boolean isUp, String orientation, double orientationVal, boolean endTurn, int turn) {
//        if (ovrTurn % 180 == 0) {
//            double mult = ovrTurn / 180;
//            orientationVal *= (Math.pow(-1, mult));
//        }
//        if (Objects.equals(orientation, "|")) {
//            double sidewaysInches = (targetX - currX) * xMult;
//            double fwdInches = (targetY - currY) * yMult;
//            fwdInches *= orientationVal;
//            sidewaysInches *= orientationVal;
//            if (currX < targetX) {
//                sideWaysEncoderDrive(power, sidewaysInches, 1);
//            } else if (currX > targetX) {
//                sideWaysEncoderDrive(power, -sidewaysInches, 1);
//            }
//            if (currY < targetY) {
//                if (!combo) {
//                    encoderDrive(power, fwdInches, fwdInches, 6);
//                } else {
//                    encoderDrive(power, fwdInches, fwdInches, 6);
//                    //arm encoder
//                }
//            } else if (currY > targetY) {
//                if (!combo) {
//                    encoderDrive(power, -fwdInches, -fwdInches, 6);
//                } else {
//                    encoderDrive(power, -fwdInches, -fwdInches, 6);
//                    //arm encoder
//                }
//            }
//        }
//        if (endTurn) {
//            turn(turn);
//        }
//        ovrTurn += turn;
//        //telemetry.addData("orientation", orientation);
//        //sleep(5000);
//    }

    //
//vu
    //public void runVu(int timeoutS, boolean giveSpot) {
    //    timer.reset();
    //    while (myOpMode.opModeIsActive()) {// and nothing given back
    //        if (timer.seconds() > timeoutS) {// is over time
    //            //auto select
    //        }
    //        if (tfod != null) {
    //            // getUpdatedRecognitions() will return null if no new information is available since
    //            // the last time that call was made.
    //            List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();
    //            if (updatedRecognitions != null) {
    //                telemetry.addData("# Objects Detected", updatedRecognitions.size());
//
    //                // step through the list of recognitions and display image position/size information for each one
    //                // Note: "Image number" refers to the randomized image orientation/number
    //                for (Recognition recognition : updatedRecognitions) {
    //                    double col = (recognition.getLeft() + recognition.getRight()) / 2;
    //                    double row = (recognition.getTop() + recognition.getBottom()) / 2;
    //                    double width = Math.abs(recognition.getRight() - recognition.getLeft());
    //                    double height = Math.abs(recognition.getTop() - recognition.getBottom());
//
    //                    telemetry.addData("", " ");
    //                    telemetry.addData("Image", "%s (%.0f %% Conf.)", recognition.getLabel(), recognition.getConfidence() * 100);
    //                    telemetry.addData("- Position (Row/Col)", "%.0f / %.0f", row, col);
    //                    telemetry.addData("- Size (Width/Height)", "%.0f / %.0f", width, height);
    //                }
    //                telemetry.update();
    //            }
    //        }
    //    }
    //}

    // color
    //public boolean colorInRange(float red, double targetR, float green, double targetG, float blue, double targetB, float range) {
    //    boolean rCheck = false;
    //    boolean gCheck = false;
    //    boolean bCheck = false;
    //    if (targetR - range < red && red < targetR + range) {
    //        rCheck = true;
    //    }
    //    if (targetG - range < green && green < targetG + range) {
    //        gCheck = true;
    //    }
    //    if (targetB - range < blue && blue < targetB + range) {
    //        bCheck = true;
    //    }
    //    return rCheck && gCheck && bCheck;
    //}
    //
    //public void getAllColorR() {
    //    //gives color values
    //    NormalizedRGBA colorsR = colorSensorR.getNormalizedColors();
    //    Color.colorToHSV(colorsR.toColor(), hsvValues);
    //    telemetry.addLine()
    //            .addData("Red", "%.3f", colorsR.red)
    //            .addData("Green", "%.3f", colorsR.green)
    //            .addData("Blue", "%.3f", colorsR.blue)
    //            .addData("Hue", "%.3f", hsvValues[0])
    //            .addData("Saturation", "%.3f", hsvValues[1])
    //            .addData("Value", "%.3f", hsvValues[2])
    //            .addData("Alpha", "%.3f", colorsR.alpha);
    //    telemetry.addLine()
    //            .addData("Color", colorName)
    //            .addData("RGB", "(" + redValR + "," + greenValR + "," + blueValR + ")");//shows rgb value
    //}
    //
    //public void getAllColorL() {
    //    //gives color values
    //    NormalizedRGBA colors = colorSensorL.getNormalizedColors();
    //    Color.colorToHSV(colors.toColor(), hsvValues);
    //    telemetry.addLine()
    //            .addData("Red", "%.3f", colors.red)
    //            .addData("Green", "%.3f", colors.green)
    //            .addData("Blue", "%.3f", colors.blue)
    //            .addData("Hue", "%.3f", hsvValues[0])
    //            .addData("Saturation", "%.3f", hsvValues[1])
    //            .addData("Value", "%.3f", hsvValues[2])
    //            .addData("Alpha", "%.3f", colors.alpha);
    //    telemetry.addLine()
    //            .addData("Color", colorName)
    //            .addData("RGB", "(" + redValL + "," + greenValL + "," + blueValL + ")");//shows rgb value
    //}
    //    public void correctByImu(float currentAngle, int targetAngle) {
    //        int angle = (int) (targetAngle - currentAngle);
    //        turn(angle);
    //    }

        //public void correctByColor() {
        //    lights.setPattern(RevBlinkinLedDriver.BlinkinPattern.BLACK);
        //    getAllColorR();
        //    getAllColorL();
        //    NormalizedRGBA colorsR = colorSensorR.getNormalizedColors();
        //    Color.colorToHSV(colorsR.toColor(), hsvValues);
        //    NormalizedRGBA colors = colorSensorL.getNormalizedColors();
        //    Color.colorToHSV(colors.toColor(), hsvValues);
        //    float redValR = colorsR.red;//the red value in rgb
        //    float greenValR = colorsR.green;//the green value in rgb
        //    float blueValR = colorsR.blue;//the blue value in rgb
        //    float redValL = colors.red;//the red value in rgb
        //    float greenValL = colors.green;//the green value in rgb
        //    float blueValL = colors.blue;//the blue value in rgb
        //    //right
        //    double redTargetRR = 0.003;//the red value in rgb
        //    double redTargetGR = 0.004;//the green value in rgb
        //    double redTargetBR = 0.003;//the blue value in rgb
        //    //left
        //    double redTargetRL = 0.003;//the red value in rgb
        //    double redTargetGL = 0.003;//the green value in rgb
        //    double redTargetBL = 0.002;//the blue value in rgb
        //    //right
        //    double blueTargetRR = 0.002;//the red value in rgb
        //    double blueTargetGR = 0.004;//the green value in rgb
        //    double blueTargetBR = 0.005;//the blue value in rgb
        //    //left
        //    double blueTargetRL = 0.001;//the red value in rgb
        //    double blueTargetGL = 0.003;//the green value in rgb
        //    double blueTargetBL = 0.0038;//the blue value in rgb
        //    double range = 0.0005;
        //    //left
        //    while (colorInRange(redValL, redTargetRL, greenValL, redTargetGL, blueValL, redTargetBL, (float) range)
        //            || colorInRange(redValL, blueTargetRL, greenValL, blueTargetGL, blueValL, blueTargetBL, (float) range)
        //            || colorInRange(redValR, redTargetRR, greenValR, redTargetGR, blueValR, redTargetBR, (float) range)
        //            || colorInRange(redValR, blueTargetRR, greenValR, blueTargetGR, blueValR, blueTargetBR, (float) range)) {
        //        if ((colorInRange(redValR, redTargetRR, greenValR, redTargetGR, blueValR, redTargetBR, (float) range)
        //                || colorInRange(redValR, blueTargetRR, greenValR, blueTargetGR, blueValR, blueTargetBR, (float) range))) {
        //            getAllColorR();
        //            sideWaysEncoderDrive(1, 0.25, 0.4);//go left
        //            //right side has seen red or blue
        //        }
        //        if (colorInRange(redValL, redTargetRL, greenValL, redTargetGL, blueValL, redTargetBL, (float) range)
        //                || colorInRange(redValL, blueTargetRL, greenValL, blueTargetGL, blueValL, blueTargetBL, (float) range)) {
        //            getAllColorL();
        //            sideWaysEncoderDrive(1, -0.25, 0.4);//go right
        //        }
        //        if (!colorInRange(redValL, redTargetRL, greenValL, redTargetGL, blueValL, redTargetBL, (float) range)
        //                || !colorInRange(redValL, blueTargetRL, greenValL, blueTargetGL, blueValL, blueTargetBL, (float) range)
        //                || !colorInRange(redValR, redTargetRR, greenValR, redTargetGR, blueValR, redTargetBR, (float) range)
        //                || !colorInRange(redValR, blueTargetRR, greenValR, blueTargetGR, blueValR, blueTargetBR, (float) range)) {
        //            break;
        //        }
        //    }
        //    lights.setPattern(RevBlinkinLedDriver.BlinkinPattern.valueOf(getColor()));
        //}


        //public void correctByTouch() {
        //    boolean pressed = touchSensor.isPressed();
        //    boolean pressedL = touchSensorL.isPressed();
        //    while (!pressed && !pressedL) {
        //        pressed = touchSensor.isPressed();
        //        pressedL = touchSensorL.isPressed();
        //        if (pressed && pressedL) {
        //            break;
        //        }
        //        encoderDrive(1, -6, -6, 1);
        //    }
        //}
//        public void simpleGoSpotRight(double currX, double currY, double targetX, double targetY, double power,
//                                      boolean combo, int pose, boolean isUp, boolean endTurn, int turn, double timeOutX,
//                                      double timeOutY, boolean prioritizeY) {
//            double XMULT = 9.0;
//            double YMULT = 20.0;
//            double sidewaysInches = (targetY - currY) * XMULT * -1;
//            double fwdInches = (targetX - currX) * YMULT;
//            if (prioritizeY) {
//                sideWaysEncoderDrive(power, sidewaysInches, timeOutY);
//                sleep(100);
//            }
//            if (!combo) {
//                encoderDrive(power, fwdInches, fwdInches, timeOutX);
//            } else {
//                encoderDrive(power, fwdInches, fwdInches, timeOutX);
//                // arm encoder
//            }
//            if (!prioritizeY) {
//                sleep(100);
//                sideWaysEncoderDrive(power, sidewaysInches, timeOutY);
//            }
//            if (endTurn) {
//                turn(turn);
//            }
//            setOvr(targetX, targetY);
//            myOpMode.telemetry.update();
//        }
//
//        public void simplerGoSpot(double currX, double currY, double targetX, double targetY, double power, boolean combo, int pose
//                , boolean isUp, boolean endTurn, int turn, int timeOutX, int timeOutY) {
//            double sidewaysInches = (targetX - currX) * xMult;
//            double fwdInches = (targetY - currY) * yMult;
//            myOpMode.telemetry.addData("fwdInches", fwdInches);
//            myOpMode.telemetry.addData("sidewaysInches", sidewaysInches);
//            myOpMode.telemetry.update();
//            sideWaysEncoderDrive(power, sidewaysInches, timeOutX);
//            if (!combo) {
//                encoderDrive(power, -fwdInches, -fwdInches, timeOutY);
//            } else {
//                encoderDrive(power, -fwdInches, -fwdInches, timeOutY);
//                // arm encoder
//            }
//            if (endTurn) {
//                turn(turn);
//            }
//            setOvr(targetX, targetY);
//            myOpMode.telemetry.update();
//        }
//        public static void setOvr(double x, double y) {
//            ovrCurrX = x;
//            ovrCurrY = y;
//        }